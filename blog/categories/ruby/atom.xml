<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Hi I'm Justin-lu]]></title>
  <link href="http://justin-lu.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://justin-lu.github.io/"/>
  <updated>2016-03-15T20:16:33+08:00</updated>
  <id>http://justin-lu.github.io/</id>
  <author>
    <name><![CDATA[Justin-lu]]></name>
    <email><![CDATA[gdjyluxiaoyong@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby中的block]]></title>
    <link href="http://justin-lu.github.io/blog/2013/10/24/rubyzhong-de-block/"/>
    <updated>2013-10-24T18:16:00+08:00</updated>
    <id>http://justin-lu.github.io/blog/2013/10/24/rubyzhong-de-block</id>
    <content type="html"><![CDATA[<p>ruby编程中的block简单介绍</p>

<!-- More -->



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ruby中的instance_eavl和class_eval]]></title>
    <link href="http://justin-lu.github.io/blog/2013/09/26/rubyzhong-de-instance-eavlhe-class-eval/"/>
    <updated>2013-09-26T12:27:00+08:00</updated>
    <id>http://justin-lu.github.io/blog/2013/09/26/rubyzhong-de-instance-eavlhe-class-eval</id>
    <content type="html"><![CDATA[<p>ruby元编程中的instance_eavl和class_eval简单介绍</p>

<!-- More -->


<p>第二次看Ruby元编程这本书，感觉里面能学到的东西很多，但是很容易忘记，所以把一些想法写下来，以备后用。</p>

<h1>instance_eval</h1>

<pre><code class="ruby">class My
  def initialize
    @v = 1
  end
end

obj = My.new
v = 3
obj.instance_eval do 
  puts self
  puts @v
  puts v
  def one_method
    puts "I'm one_method"
  end
end
#=&gt; #&lt;My:0xa2b76a4&gt;
#=&gt; 1
#=&gt; 3
obj.one_method
#=&gt; I'm one_method
obj2 = My.new
obj2.one_method
#=&gt; NoMethodError: undefined method `one_method' for #&lt;My:0xa2f3f14 @v=1&gt;
</code></pre>

<ul>
<li><p>首先，我们分析上面代码：</p>

<ul>
<li>当我们实例化一个类时，我们可以通过instance_eval来访问到该类的实例方法，所以我们可以看到<code>self</code>返回一个对象，<code>@v</code>返回1</li>
<li>由于block是一个闭包，所以在运行的时候，可以访问局部变量<code>v</code>，而且能访问局部变量@v，这种情况，我们把他叫做<code>上下文探针</code>，它就像是一个深入到对象中的代码片段，对其进行操作。</li>
<li>当我们在instance_eval块里面定义方法是，由于self为当前对象，所以 <code>def</code>关键子打开的作用域门为self，即定义的方法只有obj可以访问，我们称它为单件方法。</li>
</ul>
</li>
<li><p>然后，我们总结instance_eval的作用：</p>

<ul>
<li>instance_eval的调用者必须是一个实例</li>
<li>改变当前block的接受者为self，因此它可以访问接受者的私有方法和实例变量</li>
<li>可以在block内使用单件方法</li>
</ul>
</li>
<li><p>最后，我们还发现，可以用instance_eavl来定义类方法</p></li>
</ul>


<pre><code class="ruby">class A
end
A.instance_eval do 
  def a_method
    puts "I'm class method"
  end
end
A.a_method
#=&gt;I'm class method
</code></pre>

<h1>class_eval(又名module_eval)</h1>

<pre><code class="ruby">def add_method_to(a_class)
  a_class.class_eval do 
    puts self
    def m
      puts 'hello'
    end
  end
end
#=&gt; String

"abc".m
add_method_to String
'abc'.m
#=&gt; NoMethodError: undefined method `m' for "abc":String
#=&gt; "hello"
</code></pre>

<ul>
<li>分析上面代码，我们可以发现<code>class_eval</code>和<code>instance_eval</code>的区别：
  <em><code>class_eval</code>的调用对象必须是一个类
  </em><code>class_eval</code>block里面的self为类本身(实际上是重新打开了该类，相当于关键字<code>class</code>)
  *<code>class_eval</code>定义的方法为类的实例方法（instance_eval是单件方法）</li>
</ul>


<h1>总结：什么时候用<code>class_eval</code>和<code>instance_eval</code></h1>

<p>  <em>如果打开的对象不是类，则使用<code>instance_eval</code>,如果想打开一个类定义并且用<code>def</code>定义实例方法，则选择<code>class_eval</code>
  </em>根据调用者来决定
  *根据你的意图来决定</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby on Rails配置]]></title>
    <link href="http://justin-lu.github.io/blog/2013/07/12/ruby-on-railspei-zhi/"/>
    <updated>2013-07-12T11:32:00+08:00</updated>
    <id>http://justin-lu.github.io/blog/2013/07/12/ruby-on-railspei-zhi</id>
    <content type="html"><![CDATA[<p>安装Ruby On Rails 脚本.</p>

<!-- More -->


<ul>
<li><p>把下面内容复制到一个后缀为<code>RVM配置ROR.sh</code>新文件</p></li>
<li><p><code>chmod +x RVM配置ROR.sh</code> #变为可执行文件</p></li>
<li><p><code>./RVM配置ROR.sh</code>  执行文件</p></li>
</ul>


<pre><code class="c">echo "==========  安装函数库 ================="
sudo apt-get install curl bison build-essential git-core
sudo apt-get install zlib1g-dev libssl-dev libreadline5-dev libxml2-dev

echo "========== 安装rvm ==================="
mkdir -p ~/.rvm/src/ &amp;&amp; cd ~/.rvm/src &amp;&amp; rm -rf ./rvm/ &amp;&amp; git clone git://github.com/wayneeseguin/rvm.git &amp;&amp; cd rvm &amp;&amp; ./install

echo "========== 打开另一个终端，执行 vim ~/.bashrc ================="
echo "========== 并且将下面内容复制到.bashrc最后 ==========="
echo " if [[ -s "$HOME/.rvm/scripts/rvm" ]] ; then
source "$HOME/.rvm/scripts/rvm";
fi
[[ -s "$HOME/.rvm/scripts/rvm" ]] &amp;&amp; source "$HOME/.rvm/scripts/rvm"
"
echo "========== 修改完后请按回车键继续: =========="
read var

type rvm | head -1

rvm requirements

sudo apt-get install build-essential openssl libreadline6 libreadline6-dev curl git-core zlib1g zlib1g-dev libssl-dev libyaml-dev libsqlite3-0 libsqlite3-dev sqlite3 libxml2-dev libxslt-dev autoconf libc6-dev ncurses-dev automake libtool bison subversion

echo "=================================="
source ~/.bashrc  

echo "==================================="
sudo apt-get install rubygems

echo "========= 安装ruby1.9.2 ==========="
rvm install 1.9.2-p290

echo "======== 安装rails3.0.3 ==========="
gem install rails -v=3.0.3

echo "========= 安装ruby ==========="
rvm install 1.8.7

echo "======== 安装rails ==========="
gem install rails -v=2.3.5

echo "======= 安装mysql ============"
sudo apt-get install mysql-server
sudo apt-get install mysql-client

echo "====== 安装mysql驱动 ========="
sudo apt-get install libmysqlclient-dev 
sudo gem install mysql2 

echo "======设置默认版本=========="
rvm use --default 1.8.7

echo "============更新使用于2.3.5的rubygem========="
gem update --system 1.5.3

echo "========== 打开另一个终端，执行 vim ~/.bash_profile ================="
echo "========== 并且将下面内容复制到.bash_profile最后 ==========="
echo " 
source ~/.bashrc
"
echo "========== 修改完后请按回车键继续: =========="
read var

echo "===== 如果在此过程中，没有错误，那么Ruby on rails 环境搭配成功(Justin-lu)!! ======== "
echo "=====   QQ：448426851 ========================== "
</code></pre>
]]></content>
  </entry>
  
</feed>
